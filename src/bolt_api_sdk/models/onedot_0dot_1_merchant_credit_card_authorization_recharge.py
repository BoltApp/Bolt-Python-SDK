"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .onedot_0dot_1_address import OneDot0Dot1Address, OneDot0Dot1AddressTypedDict
from .onedot_0dot_1_cart_create import (
    OneDot0Dot1CartCreate,
    OneDot0Dot1CartCreateTypedDict,
)
from .onedot_0dot_1_processing_initiator import OneDot0Dot1ProcessingInitiator
from .onedot_0dot_1_user_identifier import (
    OneDot0Dot1UserIdentifier,
    OneDot0Dot1UserIdentifierTypedDict,
)
from .onedot_0dot_1_user_identity import (
    OneDot0Dot1UserIdentity,
    OneDot0Dot1UserIdentityTypedDict,
)
from bolt_api_sdk.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from enum import Enum
from pydantic import model_serializer
from typing import Optional
from typing_extensions import NotRequired, TypedDict


class OneDot0Dot1MerchantCreditCardAuthorizationRechargeSource(str, Enum):
    DIRECT_PAYMENTS = "direct_payments"


class OneDot0Dot1MerchantCreditCardAuthorizationRechargeTypedDict(TypedDict):
    r"""This request is used for authorizing an existing, saved card associated with the account."""

    cart: OneDot0Dot1CartCreateTypedDict
    credit_card_id: str
    r"""The unique ID associated to the saved credit card in the account's wallet."""
    division_id: str
    r"""The unique ID associated to the merchant's Bolt Account division; Merchants can have different divisions to suit multiple use cases (storefronts, pay-by-link, phone order processing). Use the Bolt Merchant Dashboard to switch between divisions and find the division ID under `Merchant Division Public ID`."""
    source: OneDot0Dot1MerchantCreditCardAuthorizationRechargeSource
    user_identifier: OneDot0Dot1UserIdentifierTypedDict
    r"""The object containing key lookup IDs associated with the shopper's account, such as the unique email address and phone number."""
    user_identity: OneDot0Dot1UserIdentityTypedDict
    auto_capture: NotRequired[bool]
    r"""This property determines how the transaction is processed after authorization. If set to `true`, the transaction is placed in a queue for automatic capture. This process is asynchronous, meaning the transaction may not immediately appear as captured after the authorization request. This is because the transaction is in a transitional state as it moves from authorization to capture. If `auto_capture` is set to `false`, the transaction is only authorized and must be manually captured."""
    merchant_event_id: NotRequired[str]
    r"""The reference ID associated with a transaction event (auth, capture, refund, void). This is an arbitrary identifier created by the merchant. Bolt does not enforce any uniqueness constraints on this ID. It is up to the merchant to generate identifiers that properly fulfill its needs."""
    previous_transaction_id: NotRequired[Nullable[str]]
    r"""The unique ID associated with to the shopper's previous subscription-based transaction. Leave `null` for standard, non-subscription transactions."""
    processing_initiator: NotRequired[OneDot0Dot1ProcessingInitiator]
    r"""Defines which payment method was used to initiate the transaction."""
    shipping_address: NotRequired[OneDot0Dot1AddressTypedDict]
    r"""The Address object is used for billing, shipping, and physical store address use cases."""


class OneDot0Dot1MerchantCreditCardAuthorizationRecharge(BaseModel):
    r"""This request is used for authorizing an existing, saved card associated with the account."""

    cart: OneDot0Dot1CartCreate

    credit_card_id: str
    r"""The unique ID associated to the saved credit card in the account's wallet."""

    division_id: str
    r"""The unique ID associated to the merchant's Bolt Account division; Merchants can have different divisions to suit multiple use cases (storefronts, pay-by-link, phone order processing). Use the Bolt Merchant Dashboard to switch between divisions and find the division ID under `Merchant Division Public ID`."""

    source: OneDot0Dot1MerchantCreditCardAuthorizationRechargeSource

    user_identifier: OneDot0Dot1UserIdentifier
    r"""The object containing key lookup IDs associated with the shopper's account, such as the unique email address and phone number."""

    user_identity: OneDot0Dot1UserIdentity

    auto_capture: Optional[bool] = None
    r"""This property determines how the transaction is processed after authorization. If set to `true`, the transaction is placed in a queue for automatic capture. This process is asynchronous, meaning the transaction may not immediately appear as captured after the authorization request. This is because the transaction is in a transitional state as it moves from authorization to capture. If `auto_capture` is set to `false`, the transaction is only authorized and must be manually captured."""

    merchant_event_id: Optional[str] = None
    r"""The reference ID associated with a transaction event (auth, capture, refund, void). This is an arbitrary identifier created by the merchant. Bolt does not enforce any uniqueness constraints on this ID. It is up to the merchant to generate identifiers that properly fulfill its needs."""

    previous_transaction_id: OptionalNullable[str] = UNSET
    r"""The unique ID associated with to the shopper's previous subscription-based transaction. Leave `null` for standard, non-subscription transactions."""

    processing_initiator: Optional[OneDot0Dot1ProcessingInitiator] = None
    r"""Defines which payment method was used to initiate the transaction."""

    shipping_address: Optional[OneDot0Dot1Address] = None
    r"""The Address object is used for billing, shipping, and physical store address use cases."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "auto_capture",
            "merchant_event_id",
            "previous_transaction_id",
            "processing_initiator",
            "shipping_address",
        ]
        nullable_fields = ["previous_transaction_id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m

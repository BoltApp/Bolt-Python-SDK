"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from bolt_api_sdk import errors, models, utils
from bolt_api_sdk._hooks import HookContext
from bolt_api_sdk.types import OptionalNullable, UNSET
from bolt_api_sdk.utils import get_security_from_env
from bolt_api_sdk.utils.unmarshal_json_response import unmarshal_json_response
from typing import Any, Mapping, Optional, Union


class Ignite3Account(BaseSDK):
    r"""Use the Accounts API to access shoppers' accounts to empower your checkout and facilitate shoppers' choices."""

    def get_details(
        self,
        *,
        security: Union[models.AccountGetSecurity, models.AccountGetSecurityTypedDict],
        x_publishable_key: str,
        x_merchant_client_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.ThreeDot3Dot7Account]:
        r"""Retrieve account details

        Retrieve a shopper's account details, such as addresses and payment information. The account's details are filtered to be relevant to your merchant account, and some fields may be missing for some accounts. See the schema for details.

        :param security:
        :param x_publishable_key: The publicly shareable identifier used to identify your Bolt merchant division.
        :param x_merchant_client_id: A unique identifier for a shopper's device, generated by Bolt. The value is retrieved with `Bolt.state.merchantClientId` in your frontend context, per-shopper. This header is required for proper attribution of this operation to your analytics reports. Omitting this header may result in incorrect statistics.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.ACCOUNT_GET_OP_SERVERS[0]
            url_variables = {
                "environment": "api-sandbox",
            }

        request = models.AccountGetRequest(
            x_publishable_key=x_publishable_key,
            x_merchant_client_id=x_merchant_client_id,
        )

        req = self._build_request(
            method="GET",
            path="/account",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.AccountGetSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="accountGet",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ThreeDot3Dot7Account, http_res)
        if utils.match_response(http_res, "4XX", "application/json"):
            response_data = unmarshal_json_response(
                errors.ThreeDot3Dot7Response4xxUnion, http_res
            )
            raise errors.ThreeDot3Dot7Response4xx(response_data, http_res)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "*"):
            return None

        raise errors.APIError("Unexpected response received", http_res)

    async def get_details_async(
        self,
        *,
        security: Union[models.AccountGetSecurity, models.AccountGetSecurityTypedDict],
        x_publishable_key: str,
        x_merchant_client_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.ThreeDot3Dot7Account]:
        r"""Retrieve account details

        Retrieve a shopper's account details, such as addresses and payment information. The account's details are filtered to be relevant to your merchant account, and some fields may be missing for some accounts. See the schema for details.

        :param security:
        :param x_publishable_key: The publicly shareable identifier used to identify your Bolt merchant division.
        :param x_merchant_client_id: A unique identifier for a shopper's device, generated by Bolt. The value is retrieved with `Bolt.state.merchantClientId` in your frontend context, per-shopper. This header is required for proper attribution of this operation to your analytics reports. Omitting this header may result in incorrect statistics.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.ACCOUNT_GET_OP_SERVERS[0]
            url_variables = {
                "environment": "api-sandbox",
            }

        request = models.AccountGetRequest(
            x_publishable_key=x_publishable_key,
            x_merchant_client_id=x_merchant_client_id,
        )

        req = self._build_request_async(
            method="GET",
            path="/account",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(security, models.AccountGetSecurity),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="accountGet",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ThreeDot3Dot7Account, http_res)
        if utils.match_response(http_res, "4XX", "application/json"):
            response_data = unmarshal_json_response(
                errors.ThreeDot3Dot7Response4xxUnion, http_res
            )
            raise errors.ThreeDot3Dot7Response4xx(response_data, http_res)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "*"):
            return None

        raise errors.APIError("Unexpected response received", http_res)

    def add_address(
        self,
        *,
        security: Union[
            models.AccountAddressCreateSecurity,
            models.AccountAddressCreateSecurityTypedDict,
        ],
        x_publishable_key: str,
        first_name: str,
        last_name: str,
        street_address1: str,
        locality: str,
        postal_code: str,
        country_code: models.ThreeDot3Dot7CountryCode,
        x_merchant_client_id: Optional[str] = None,
        company: Optional[str] = None,
        street_address2: Optional[str] = None,
        region: Optional[str] = None,
        email: Optional[str] = None,
        phone: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.ThreeDot3Dot7AddressListing]:
        r"""Add an address

        Add an address to the shopper's account

        :param security:
        :param x_publishable_key: The publicly shareable identifier used to identify your Bolt merchant division.
        :param first_name: The first name of the person associated with this address.
        :param last_name: The last name of the person associated with this address.
        :param street_address1: The street address associated with this address.
        :param locality: The locality (e.g. city, town, etc...) associated with this address.
        :param postal_code: The postal code associated with this address.
        :param country_code: The country (in its ISO 3166 alpha-2 format) associated with this address.
        :param x_merchant_client_id: A unique identifier for a shopper's device, generated by Bolt. The value is retrieved with `Bolt.state.merchantClientId` in your frontend context, per-shopper. This header is required for proper attribution of this operation to your analytics reports. Omitting this header may result in incorrect statistics.
        :param company: The company associated with this address.
        :param street_address2: Any additional, optional, street address information associated with this address.
        :param region: The region or administrative area (e.g. state, province, county, etc...) associated with this address.
        :param email: The email address associated with this address.
        :param phone: The phone number associated with this address.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.ACCOUNT_ADDRESS_CREATE_OP_SERVERS[0]
            url_variables = {
                "environment": "api-sandbox",
            }

        request = models.AccountAddressCreateRequest(
            x_publishable_key=x_publishable_key,
            x_merchant_client_id=x_merchant_client_id,
            three_dot_3_dot_7_address_listing=models.ThreeDot3Dot7AddressListingInput(
                first_name=first_name,
                last_name=last_name,
                company=company,
                street_address1=street_address1,
                street_address2=street_address2,
                locality=locality,
                postal_code=postal_code,
                region=region,
                country_code=country_code,
                email=email,
                phone=phone,
            ),
        )

        req = self._build_request(
            method="POST",
            path="/account/addresses",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.AccountAddressCreateSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.three_dot_3_dot_7_address_listing,
                False,
                False,
                "json",
                models.ThreeDot3Dot7AddressListingInput,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="accountAddressCreate",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ThreeDot3Dot7AddressListing, http_res)
        if utils.match_response(http_res, "4XX", "application/json"):
            response_data = unmarshal_json_response(
                errors.ThreeDot3Dot7ResponseAddressErrorUnion, http_res
            )
            raise errors.ThreeDot3Dot7ResponseAddressError(response_data, http_res)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "*"):
            return None

        raise errors.APIError("Unexpected response received", http_res)

    async def add_address_async(
        self,
        *,
        security: Union[
            models.AccountAddressCreateSecurity,
            models.AccountAddressCreateSecurityTypedDict,
        ],
        x_publishable_key: str,
        first_name: str,
        last_name: str,
        street_address1: str,
        locality: str,
        postal_code: str,
        country_code: models.ThreeDot3Dot7CountryCode,
        x_merchant_client_id: Optional[str] = None,
        company: Optional[str] = None,
        street_address2: Optional[str] = None,
        region: Optional[str] = None,
        email: Optional[str] = None,
        phone: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.ThreeDot3Dot7AddressListing]:
        r"""Add an address

        Add an address to the shopper's account

        :param security:
        :param x_publishable_key: The publicly shareable identifier used to identify your Bolt merchant division.
        :param first_name: The first name of the person associated with this address.
        :param last_name: The last name of the person associated with this address.
        :param street_address1: The street address associated with this address.
        :param locality: The locality (e.g. city, town, etc...) associated with this address.
        :param postal_code: The postal code associated with this address.
        :param country_code: The country (in its ISO 3166 alpha-2 format) associated with this address.
        :param x_merchant_client_id: A unique identifier for a shopper's device, generated by Bolt. The value is retrieved with `Bolt.state.merchantClientId` in your frontend context, per-shopper. This header is required for proper attribution of this operation to your analytics reports. Omitting this header may result in incorrect statistics.
        :param company: The company associated with this address.
        :param street_address2: Any additional, optional, street address information associated with this address.
        :param region: The region or administrative area (e.g. state, province, county, etc...) associated with this address.
        :param email: The email address associated with this address.
        :param phone: The phone number associated with this address.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.ACCOUNT_ADDRESS_CREATE_OP_SERVERS[0]
            url_variables = {
                "environment": "api-sandbox",
            }

        request = models.AccountAddressCreateRequest(
            x_publishable_key=x_publishable_key,
            x_merchant_client_id=x_merchant_client_id,
            three_dot_3_dot_7_address_listing=models.ThreeDot3Dot7AddressListingInput(
                first_name=first_name,
                last_name=last_name,
                company=company,
                street_address1=street_address1,
                street_address2=street_address2,
                locality=locality,
                postal_code=postal_code,
                region=region,
                country_code=country_code,
                email=email,
                phone=phone,
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/account/addresses",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.AccountAddressCreateSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.three_dot_3_dot_7_address_listing,
                False,
                False,
                "json",
                models.ThreeDot3Dot7AddressListingInput,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="accountAddressCreate",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ThreeDot3Dot7AddressListing, http_res)
        if utils.match_response(http_res, "4XX", "application/json"):
            response_data = unmarshal_json_response(
                errors.ThreeDot3Dot7ResponseAddressErrorUnion, http_res
            )
            raise errors.ThreeDot3Dot7ResponseAddressError(response_data, http_res)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "*"):
            return None

        raise errors.APIError("Unexpected response received", http_res)

    def update_address(
        self,
        *,
        security: Union[
            models.AccountAddressEditSecurity,
            models.AccountAddressEditSecurityTypedDict,
        ],
        x_publishable_key: str,
        id: str,
        first_name: str,
        last_name: str,
        street_address1: str,
        locality: str,
        postal_code: str,
        country_code: models.ThreeDot3Dot7CountryCode,
        x_merchant_client_id: Optional[str] = None,
        company: Optional[str] = None,
        street_address2: Optional[str] = None,
        region: Optional[str] = None,
        email: Optional[str] = None,
        phone: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.ThreeDot3Dot7AddressListing]:
        r"""Edit an existing address

        Edit an existing address on the shopper's account. This does not edit addresses that are already associated with other resources, such as transactions or shipments.

        :param security:
        :param x_publishable_key: The publicly shareable identifier used to identify your Bolt merchant division.
        :param id: The ID of the address to edit
        :param first_name: The first name of the person associated with this address.
        :param last_name: The last name of the person associated with this address.
        :param street_address1: The street address associated with this address.
        :param locality: The locality (e.g. city, town, etc...) associated with this address.
        :param postal_code: The postal code associated with this address.
        :param country_code: The country (in its ISO 3166 alpha-2 format) associated with this address.
        :param x_merchant_client_id: A unique identifier for a shopper's device, generated by Bolt. The value is retrieved with `Bolt.state.merchantClientId` in your frontend context, per-shopper. This header is required for proper attribution of this operation to your analytics reports. Omitting this header may result in incorrect statistics.
        :param company: The company associated with this address.
        :param street_address2: Any additional, optional, street address information associated with this address.
        :param region: The region or administrative area (e.g. state, province, county, etc...) associated with this address.
        :param email: The email address associated with this address.
        :param phone: The phone number associated with this address.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.ACCOUNT_ADDRESS_EDIT_OP_SERVERS[0]
            url_variables = {
                "environment": "api-sandbox",
            }

        request = models.AccountAddressEditRequest(
            x_publishable_key=x_publishable_key,
            x_merchant_client_id=x_merchant_client_id,
            id=id,
            three_dot_3_dot_7_address_listing=models.ThreeDot3Dot7AddressListingInput(
                first_name=first_name,
                last_name=last_name,
                company=company,
                street_address1=street_address1,
                street_address2=street_address2,
                locality=locality,
                postal_code=postal_code,
                region=region,
                country_code=country_code,
                email=email,
                phone=phone,
            ),
        )

        req = self._build_request(
            method="PUT",
            path="/account/addresses/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.AccountAddressEditSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.three_dot_3_dot_7_address_listing,
                False,
                False,
                "json",
                models.ThreeDot3Dot7AddressListingInput,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="accountAddressEdit",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ThreeDot3Dot7AddressListing, http_res)
        if utils.match_response(http_res, "4XX", "application/json"):
            response_data = unmarshal_json_response(
                errors.ThreeDot3Dot7ResponseAddressErrorUnion, http_res
            )
            raise errors.ThreeDot3Dot7ResponseAddressError(response_data, http_res)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "*"):
            return None

        raise errors.APIError("Unexpected response received", http_res)

    async def update_address_async(
        self,
        *,
        security: Union[
            models.AccountAddressEditSecurity,
            models.AccountAddressEditSecurityTypedDict,
        ],
        x_publishable_key: str,
        id: str,
        first_name: str,
        last_name: str,
        street_address1: str,
        locality: str,
        postal_code: str,
        country_code: models.ThreeDot3Dot7CountryCode,
        x_merchant_client_id: Optional[str] = None,
        company: Optional[str] = None,
        street_address2: Optional[str] = None,
        region: Optional[str] = None,
        email: Optional[str] = None,
        phone: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.ThreeDot3Dot7AddressListing]:
        r"""Edit an existing address

        Edit an existing address on the shopper's account. This does not edit addresses that are already associated with other resources, such as transactions or shipments.

        :param security:
        :param x_publishable_key: The publicly shareable identifier used to identify your Bolt merchant division.
        :param id: The ID of the address to edit
        :param first_name: The first name of the person associated with this address.
        :param last_name: The last name of the person associated with this address.
        :param street_address1: The street address associated with this address.
        :param locality: The locality (e.g. city, town, etc...) associated with this address.
        :param postal_code: The postal code associated with this address.
        :param country_code: The country (in its ISO 3166 alpha-2 format) associated with this address.
        :param x_merchant_client_id: A unique identifier for a shopper's device, generated by Bolt. The value is retrieved with `Bolt.state.merchantClientId` in your frontend context, per-shopper. This header is required for proper attribution of this operation to your analytics reports. Omitting this header may result in incorrect statistics.
        :param company: The company associated with this address.
        :param street_address2: Any additional, optional, street address information associated with this address.
        :param region: The region or administrative area (e.g. state, province, county, etc...) associated with this address.
        :param email: The email address associated with this address.
        :param phone: The phone number associated with this address.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.ACCOUNT_ADDRESS_EDIT_OP_SERVERS[0]
            url_variables = {
                "environment": "api-sandbox",
            }

        request = models.AccountAddressEditRequest(
            x_publishable_key=x_publishable_key,
            x_merchant_client_id=x_merchant_client_id,
            id=id,
            three_dot_3_dot_7_address_listing=models.ThreeDot3Dot7AddressListingInput(
                first_name=first_name,
                last_name=last_name,
                company=company,
                street_address1=street_address1,
                street_address2=street_address2,
                locality=locality,
                postal_code=postal_code,
                region=region,
                country_code=country_code,
                email=email,
                phone=phone,
            ),
        )

        req = self._build_request_async(
            method="PUT",
            path="/account/addresses/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.AccountAddressEditSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.three_dot_3_dot_7_address_listing,
                False,
                False,
                "json",
                models.ThreeDot3Dot7AddressListingInput,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="accountAddressEdit",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.ThreeDot3Dot7AddressListing, http_res)
        if utils.match_response(http_res, "4XX", "application/json"):
            response_data = unmarshal_json_response(
                errors.ThreeDot3Dot7ResponseAddressErrorUnion, http_res
            )
            raise errors.ThreeDot3Dot7ResponseAddressError(response_data, http_res)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "*"):
            return None

        raise errors.APIError("Unexpected response received", http_res)

    def delete_address(
        self,
        *,
        security: Union[
            models.AccountAddressDeleteSecurity,
            models.AccountAddressDeleteSecurityTypedDict,
        ],
        x_publishable_key: str,
        id: str,
        x_merchant_client_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete an existing address

        Delete an existing address. Deleting an address does not invalidate or remove the address from transactions or shipments that are associated with it.

        :param security:
        :param x_publishable_key: The publicly shareable identifier used to identify your Bolt merchant division.
        :param id: The ID of the address to delete
        :param x_merchant_client_id: A unique identifier for a shopper's device, generated by Bolt. The value is retrieved with `Bolt.state.merchantClientId` in your frontend context, per-shopper. This header is required for proper attribution of this operation to your analytics reports. Omitting this header may result in incorrect statistics.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.ACCOUNT_ADDRESS_DELETE_OP_SERVERS[0]
            url_variables = {
                "environment": "api-sandbox",
            }

        request = models.AccountAddressDeleteRequest(
            x_publishable_key=x_publishable_key,
            x_merchant_client_id=x_merchant_client_id,
            id=id,
        )

        req = self._build_request(
            method="DELETE",
            path="/account/addresses/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.AccountAddressDeleteSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="accountAddressDelete",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, "4XX", "application/json"):
            response_data = unmarshal_json_response(
                errors.ThreeDot3Dot7Response4xxUnion, http_res
            )
            raise errors.ThreeDot3Dot7Response4xx(response_data, http_res)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "*"):
            return

        raise errors.APIError("Unexpected response received", http_res)

    async def delete_address_async(
        self,
        *,
        security: Union[
            models.AccountAddressDeleteSecurity,
            models.AccountAddressDeleteSecurityTypedDict,
        ],
        x_publishable_key: str,
        id: str,
        x_merchant_client_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete an existing address

        Delete an existing address. Deleting an address does not invalidate or remove the address from transactions or shipments that are associated with it.

        :param security:
        :param x_publishable_key: The publicly shareable identifier used to identify your Bolt merchant division.
        :param id: The ID of the address to delete
        :param x_merchant_client_id: A unique identifier for a shopper's device, generated by Bolt. The value is retrieved with `Bolt.state.merchantClientId` in your frontend context, per-shopper. This header is required for proper attribution of this operation to your analytics reports. Omitting this header may result in incorrect statistics.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.ACCOUNT_ADDRESS_DELETE_OP_SERVERS[0]
            url_variables = {
                "environment": "api-sandbox",
            }

        request = models.AccountAddressDeleteRequest(
            x_publishable_key=x_publishable_key,
            x_merchant_client_id=x_merchant_client_id,
            id=id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/account/addresses/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.AccountAddressDeleteSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="accountAddressDelete",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, "4XX", "application/json"):
            response_data = unmarshal_json_response(
                errors.ThreeDot3Dot7Response4xxUnion, http_res
            )
            raise errors.ThreeDot3Dot7Response4xx(response_data, http_res)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "*"):
            return

        raise errors.APIError("Unexpected response received", http_res)

    def add_payment_method(
        self,
        *,
        security: Union[
            models.AccountAddPaymentMethodSecurity,
            models.AccountAddPaymentMethodSecurityTypedDict,
        ],
        x_publishable_key: str,
        three_dot_3_dot_7_payment_method: Union[
            models.ThreeDot3Dot7PaymentMethodInput,
            models.ThreeDot3Dot7PaymentMethodInputTypedDict,
        ],
        x_merchant_client_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.ThreeDot3Dot7PaymentMethodOutput]:
        r"""Add a payment method

        Add a payment method to a shopper's Bolt Account Wallet. For security purposes, this request must come from your backend. <br/> **Note**: Before using this API, the credit card details must be tokenized by Bolt's credit card tokenization service. Please review our [Bolt Payment Field Component](https://help.bolt.com/products/ignite/api-implementation/#enhance-payments) or [Install the Bolt Tokenizer](https://help.bolt.com/developers/references/bolt-tokenizer) documentation.

        :param security:
        :param x_publishable_key: The publicly shareable identifier used to identify your Bolt merchant division.
        :param three_dot_3_dot_7_payment_method:
        :param x_merchant_client_id: A unique identifier for a shopper's device, generated by Bolt. The value is retrieved with `Bolt.state.merchantClientId` in your frontend context, per-shopper. This header is required for proper attribution of this operation to your analytics reports. Omitting this header may result in incorrect statistics.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.ACCOUNT_ADD_PAYMENT_METHOD_OP_SERVERS[0]
            url_variables = {
                "environment": "api-sandbox",
            }

        request = models.AccountAddPaymentMethodRequest(
            x_publishable_key=x_publishable_key,
            x_merchant_client_id=x_merchant_client_id,
            three_dot_3_dot_7_payment_method=utils.get_pydantic_model(
                three_dot_3_dot_7_payment_method, models.ThreeDot3Dot7PaymentMethodInput
            ),
        )

        req = self._build_request(
            method="POST",
            path="/account/payment-methods",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.AccountAddPaymentMethodSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.three_dot_3_dot_7_payment_method,
                False,
                False,
                "json",
                models.ThreeDot3Dot7PaymentMethodInput,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="accountAddPaymentMethod",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.ThreeDot3Dot7PaymentMethodOutput, http_res
            )
        if utils.match_response(http_res, "4XX", "application/json"):
            response_data = unmarshal_json_response(
                errors.ThreeDot3Dot7ResponsePaymentMethodErrorUnion, http_res
            )
            raise errors.ThreeDot3Dot7ResponsePaymentMethodError(
                response_data, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "*"):
            return None

        raise errors.APIError("Unexpected response received", http_res)

    async def add_payment_method_async(
        self,
        *,
        security: Union[
            models.AccountAddPaymentMethodSecurity,
            models.AccountAddPaymentMethodSecurityTypedDict,
        ],
        x_publishable_key: str,
        three_dot_3_dot_7_payment_method: Union[
            models.ThreeDot3Dot7PaymentMethodInput,
            models.ThreeDot3Dot7PaymentMethodInputTypedDict,
        ],
        x_merchant_client_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Optional[models.ThreeDot3Dot7PaymentMethodOutput]:
        r"""Add a payment method

        Add a payment method to a shopper's Bolt Account Wallet. For security purposes, this request must come from your backend. <br/> **Note**: Before using this API, the credit card details must be tokenized by Bolt's credit card tokenization service. Please review our [Bolt Payment Field Component](https://help.bolt.com/products/ignite/api-implementation/#enhance-payments) or [Install the Bolt Tokenizer](https://help.bolt.com/developers/references/bolt-tokenizer) documentation.

        :param security:
        :param x_publishable_key: The publicly shareable identifier used to identify your Bolt merchant division.
        :param three_dot_3_dot_7_payment_method:
        :param x_merchant_client_id: A unique identifier for a shopper's device, generated by Bolt. The value is retrieved with `Bolt.state.merchantClientId` in your frontend context, per-shopper. This header is required for proper attribution of this operation to your analytics reports. Omitting this header may result in incorrect statistics.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.ACCOUNT_ADD_PAYMENT_METHOD_OP_SERVERS[0]
            url_variables = {
                "environment": "api-sandbox",
            }

        request = models.AccountAddPaymentMethodRequest(
            x_publishable_key=x_publishable_key,
            x_merchant_client_id=x_merchant_client_id,
            three_dot_3_dot_7_payment_method=utils.get_pydantic_model(
                three_dot_3_dot_7_payment_method, models.ThreeDot3Dot7PaymentMethodInput
            ),
        )

        req = self._build_request_async(
            method="POST",
            path="/account/payment-methods",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.AccountAddPaymentMethodSecurity
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.three_dot_3_dot_7_payment_method,
                False,
                False,
                "json",
                models.ThreeDot3Dot7PaymentMethodInput,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="accountAddPaymentMethod",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.ThreeDot3Dot7PaymentMethodOutput, http_res
            )
        if utils.match_response(http_res, "4XX", "application/json"):
            response_data = unmarshal_json_response(
                errors.ThreeDot3Dot7ResponsePaymentMethodErrorUnion, http_res
            )
            raise errors.ThreeDot3Dot7ResponsePaymentMethodError(
                response_data, http_res
            )
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "*"):
            return None

        raise errors.APIError("Unexpected response received", http_res)

    def delete_payment_method(
        self,
        *,
        security: Union[
            models.AccountPaymentMethodDeleteSecurity,
            models.AccountPaymentMethodDeleteSecurityTypedDict,
        ],
        x_publishable_key: str,
        id: str,
        x_merchant_client_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete an existing payment method

        Delete an existing payment method. Deleting a payment method does not invalidate or remove it from transactions or orders that are associated with it.

        :param security:
        :param x_publishable_key: The publicly shareable identifier used to identify your Bolt merchant division.
        :param id: The ID of the payment method to delete
        :param x_merchant_client_id: A unique identifier for a shopper's device, generated by Bolt. The value is retrieved with `Bolt.state.merchantClientId` in your frontend context, per-shopper. This header is required for proper attribution of this operation to your analytics reports. Omitting this header may result in incorrect statistics.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.ACCOUNT_PAYMENT_METHOD_DELETE_OP_SERVERS[0]
            url_variables = {
                "environment": "api-sandbox",
            }

        request = models.AccountPaymentMethodDeleteRequest(
            x_publishable_key=x_publishable_key,
            x_merchant_client_id=x_merchant_client_id,
            id=id,
        )

        req = self._build_request(
            method="DELETE",
            path="/account/payment-methods/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.AccountPaymentMethodDeleteSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="accountPaymentMethodDelete",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, "4XX", "application/json"):
            response_data = unmarshal_json_response(
                errors.ThreeDot3Dot7Response4xxUnion, http_res
            )
            raise errors.ThreeDot3Dot7Response4xx(response_data, http_res)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "*"):
            return

        raise errors.APIError("Unexpected response received", http_res)

    async def delete_payment_method_async(
        self,
        *,
        security: Union[
            models.AccountPaymentMethodDeleteSecurity,
            models.AccountPaymentMethodDeleteSecurityTypedDict,
        ],
        x_publishable_key: str,
        id: str,
        x_merchant_client_id: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ):
        r"""Delete an existing payment method

        Delete an existing payment method. Deleting a payment method does not invalidate or remove it from transactions or orders that are associated with it.

        :param security:
        :param x_publishable_key: The publicly shareable identifier used to identify your Bolt merchant division.
        :param id: The ID of the payment method to delete
        :param x_merchant_client_id: A unique identifier for a shopper's device, generated by Bolt. The value is retrieved with `Bolt.state.merchantClientId` in your frontend context, per-shopper. This header is required for proper attribution of this operation to your analytics reports. Omitting this header may result in incorrect statistics.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = models.ACCOUNT_PAYMENT_METHOD_DELETE_OP_SERVERS[0]
            url_variables = {
                "environment": "api-sandbox",
            }

        request = models.AccountPaymentMethodDeleteRequest(
            x_publishable_key=x_publishable_key,
            x_merchant_client_id=x_merchant_client_id,
            id=id,
        )

        req = self._build_request_async(
            method="DELETE",
            path="/account/payment-methods/{id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=utils.get_pydantic_model(
                security, models.AccountPaymentMethodDeleteSecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="accountPaymentMethodDelete",
                oauth2_scopes=None,
                security_source=get_security_from_env(security, models.Security),
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        response_data: Any = None
        if utils.match_response(http_res, "200", "*"):
            return
        if utils.match_response(http_res, "4XX", "application/json"):
            response_data = unmarshal_json_response(
                errors.ThreeDot3Dot7Response4xxUnion, http_res
            )
            raise errors.ThreeDot3Dot7Response4xx(response_data, http_res)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.APIError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "default", "*"):
            return

        raise errors.APIError("Unexpected response received", http_res)
